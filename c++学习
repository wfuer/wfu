常量指针只能改变地址不能改变内存值。   const int *p = &a;  p = &b;
指针常量不能改地址可以改值   int * const p = &a;   *p = 20;
即修饰指针又修饰常量都不能改  const int * const p = &a;  无法更改。
ctrl + r 是回退

代码区：共享的  只读的
全局区：存全局变量、静态变量、常量、const修饰全局变量、字符串常量。 由操作系统控制生命周期
栈区：存函数的参数和局部变量。 由编译器自动分配和释放（不要返回局部变量的地址。）
堆区：由程序员分配释放，如果不释放，程序结束时由操作系统回收。  c++中主要用new在堆区中开辟内存

引用：
引用必须初始化，且一但初始化就不可更改引用。
引用传递也会修饰实参
不要返回局部变量的引用
函数的调用可以作为左值
引用的本质在c++内部实现就是指针常量（可改值不可改地址）
int& add = a; 等价于 int * const p = &a;
常量引用：
用来修饰形参，防止误操作
引用必须引用在栈区或者堆区的数据
const int &add = 10 ; 等价于int a = 10； const int * const add = &a; 仅可读，不能改写。

类中的属性和行为统一称为成员。
属性也叫成员属性 成员变量
行为也叫成员方法 成员函数

函数的默认参数：
会被实参覆盖
如果某个位置已经有了默认参数，那么从这个位置往后，从左到右必须要有默认参数
函数声明和函数定义只能出现一次默认参数

函数的占位参数：
可以有默认参数

函数重载：
函数名可以相同，提高重复性
条件：
同一作用域下，函数名相同，参数类型不同或个数不同或顺序不同
注意事项：
1、引用作为重载的条件   
2、碰到默认参数，出现二义性，报错。


封装、继承、多态
